---
title: "Extending DAISIEprep ASR models"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Extending DAISIEprep ASR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(DAISIEprep)
```

The methods that `DAISIEprep` provides to run ancestral state reconstruction 
(ASR) are parsimony and the Markov model (Mk) using functionality from the R package `castor`. These are provided as standard in the `DAISIEprep::add_asr_node_states()` function to easily allow a user to run a
reconstruction to be later used by the `asr` algorithm in the `extract_island_species()` function (this being the central function of the
`DAISIEprep` package). The parsimony and the Mk model provide simple models 
that have been widely used in evolutionary biology since their development. For
details on the parsimony method see documentation for `castor::asr_max_parsimony()` and for details on the Mk model see documentation
for `castor::asr_mk_model()`.

Here we show the same example as in the Tutorial vignette to show how both 
methods are implemented: 

```{r, add_asr_node_state example}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
phylo <- ape::rcoal(10)

phylo$tip.label <- c("bird_a", "bird_b", "bird_c", "bird_d", "bird_e", "bird_f",
                     "bird_g", "bird_h", "bird_i", "bird_j")

phylo <- phylobase::phylo4(phylo)

endemicity_status <- sample(
  x = c("not_present", "endemic", "nonendemic"), 
  size = length(phylobase::tipLabels(phylo)), 
  replace = TRUE,
  prob = c(0.6, 0.2, 0.2)
)

phylod <- phylobase::phylo4d(phylo, as.data.frame(endemicity_status))

# reconstruction using parsimony
phylod_parsimony <- add_asr_node_states(
  phylod = phylod, 
  asr_method = "parsimony")

# reconstruction using Mk model
phylod_parsimony <- add_asr_node_states(
  phylod = phylod, 
  asr_method = "parsimony"
)
```

For details on the internal workings of the `add_asr_node_states()` function see appendix at the bottom of this article.

However, there are many models developed for the reconstruction of states
(traits) on a phylogenetic tree and thus it may be more appropriate to use
a different type of model for the empirical group being studied. Just as R is 
developed to allow for packages to [extend the language](https://cran.r-project.org/doc/manuals/r-release/R-exts.html), `DAISIEprep` is designed
to allow each extension of ASR methods for incorporation with key functions 
(e.g. `extract_island_species()`). 

Here we give examples of three packages that can be used an extensions: `diversitree`, `BioGeoBEARS` and `corHMM`. 

`diversitree` is a packages containing a suite of State Speciation and 
Extinction (SSE) model which can
reconstruct ancestral states under a model in which the rates of speciation,
extinction and transition between states all influence the reconstruction. These
models prevent the bias of having many species in a state because of high speciation but a model, such as the Mk model, assumes it is due to high 
transition rates into that state (see Maddison, 2006). The example we give uses
the MuSSE model with a three states (island endemic, island non-endemic and not 
present on the island), but other SSE models in `diversitree` can
be applied in the same manner. 

`BioGeoBEARS` is a widely used package that includes the DEC and DEC+J models of biogeographic reconstruction. Therefore, it may be that people familiar with 
these models want to apply them for extracting island colonisations for DAISIE. 

Lastly, `corHMM` is a package that implements a hidden markov model of evolution, similar to the Mk model, but can better account for rate heterogeneity by introducing hidden states into the model. Each model can be argued for or against; with the choice influenced by the taxonomic group being studied.

## Introduction


### ASR with DAISIE?
Why ASR with other models?
Users may want to model the biogeographic process with processes not captured by DAISIE,
for example the existence of more areas than mainland + island (e.g., an archipelago).
Or some processes left out by DAISIE, like back-colonisation from the island to mainland.

Ultimately, DAISIE will only consider island biota for analysis of the diversification process on the island, but interactions between mainland and island may be deemed relevant for constituting the island biota.

## Example data

We consider the following randomly generated phylogeny and tip data:

```{r, sample_tree, include=FALSE}
set.seed(
  2,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
phylo <- ape::rcoal(20)

phylo$tip.label <- paste0("bird_", letters[1:20])

phylo <- phylobase::phylo4(phylo)

endemicity_status <- sample(
  x = c("not_present", "endemic", "nonendemic"), 
  size = length(phylobase::tipLabels(phylo)), 
  replace = TRUE,
  prob = c(0.45, 0.45, 0.1)
)

phylod <- phylobase::phylo4d(phylo, as.data.frame(endemicity_status))

# Need the outside clade to be an outgroup
phylod@data$endemicity_status[17] <- "not_present"

plot_phylod(phylod)
```
## DEC+J

As a first example, we consider the popular DEC (Dispersal-Extinction-Cladogenesis) model [@ree_maximum_2008] with founder-event speciation (DEC+J, @matzke_probabilistic_2013), implemented in R in the **biogeobears** package [@biogeobears].

```{r, load_biogeobears}
require(BioGeoBEARS)
```

BioGeoBEARS revolves around an object, `BioGeoBEARS_run`, which stores input data, the structure of the model to optimise, and control parameters for optimisation.

```{r}
# Default structure of the BioGeoBEARS object
bgb_run <- define_BioGeoBEARS_run()
bgb_run
```
Many elements of this list are only relevant for advanced options of the model and can be ignored if these features are not used. For example, BioGeoBEARS allow explicit modelling of the connectivity between areas and time-dependent availability of the areas.
In this example, we focus on a simple dispersal scenario between two areas (mainland and island),  so these elements can be ignored. We direct the interested user to the [relevant tutorial](http://phylo.wikidot.com/biogeobears#toc17) on the BioGeoBEARS website.

BioGeoBEARS expects at least two inputs, the phylogeny and the biogeographic data, a matrix of tip states. Both must be supplied as paths to files which will be read when the model is run.

The tree can be supplied in Newick or Nexus format, as a text file.

```{r biogeobears_tree_input}
path_to_phylo <- tempfile(pattern = "phylo_", fileext = ".txt")
phylo <- as(phylod, "phylo")
ape::write.tree(phylo, file = path_to_phylo)

bgb_run$trfn <- path_to_phylo
```

Tip data must be supplied as a text file specifying presence/absence of every tip in each area, in the format used by the [PHYLIP](https://evolution.genetics.washington.edu/phylip.html) sofware suite. We report the full specifications from the [BioGeoBEARS](http://phylo.wikidot.com/biogeobears#script) tutorial 

```
#######################################################
# Geography file
# Notes:
# 1. This is a PHYLIP-formatted file. This means that in the 
#    first line, 
#    - the 1st number equals the number of rows (species)
#    - the 2nd number equals the number of columns (number of areas)
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)
#
# 1.5. Example first line:
#    10    4    (A B C D)
# 
# 2. The second line, and subsequent lines:
#    speciesA    0110
#    speciesB    0111
#    speciesC    0001
#         ...
# 
# 2.5a. This means a TAB between the species name and the area 0/1s
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.
# 
# 3. See example files at:
#    http://phylo.wikidot.com/biogeobears#files
# 
# 4. Make you understand what a PLAIN-TEXT EDITOR is:
#    http://phylo.wikidot.com/biogeobears#texteditors
#
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.
#
# 4. All names in the geography file must match names in the phylogeny file.
#
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"
#
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, 
#    i.e. genetically isolated populations.  These may or may not be identical 
#    with species.  You would NOT want to just use specimens, as each specimen 
#    automatically can only live in 1 area, which will typically favor DEC+J 
#    models.  This is fine if the species/lineages really do live in single areas,
#    but you wouldn't want to assume this without thinking about it at least. 
#    In summary, you should collapse multiple specimens into species/lineages if 
#    data indicates they are the same genetic population.
######################################################
```

For convenience, we have included a function that writes this file from a `phylod` object for the simple mainland-island case.

```{r biogeobears_geo_input}
path_to_biogeo <- tempfile(pattern = "biogeo_", fileext = ".txt")
write_phylip_biogeo_file(phylod, path_to_biogeo)
BioGeoBEARS::getranges_from_LagrangePHYLIP(path_to_biogeo)
bgb_run$geogfn <- path_to_biogeo
```
While we were at it, we have nested this function in `write_biogeobears_input()`, to prepare both this file and the Newick file above in one command

```{r, write_biogeobears_input}
path_to_phylo <- tempfile(pattern = "phylo_", fileext = ".txt")
path_to_biogeo <- tempfile(pattern = "biogeo_", fileext = ".txt")
write_biogeobears_input(phylod, path_to_phylo, path_to_biogeo)

bgb_run$trfn <- path_to_phylo
bgb_run$geogfn <- path_to_biogeo
```

The structure of the model is contained in `BioGeoBEARS_model_object`. This is simply a table that contains the status (fixed or free), values (initial, min/max boundaries and estimated value if free) and documentation of each parameter of the supermodel. 

```{r}
bgb_run$BioGeoBEARS_model_object
```

BioGeoBEARS is indeed built as a supermodel which parameters can be turned on or off to reproduce biogeographic models like DEC, DIVA, BayArea and/or expand them.

See Fig. 1 in @matzke_probabilistic_2013 for an overview of the supermodel and parameters:

```{r}
knitr::include_graphics("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_supermodel.png")
# do we need to ask for authorisation to reproduce this figure?
```

Note that by default, all parameters but *d* and *e* are turned off (i.e., fixed and set to a value such that they cause no effect). That is, by default, `BioGeoBEARS_model_object` specifies the DEC model.

For this example, we simply modify the model to make *j* a free parameter, and thus turn the model into DEC+J.

```{r, make_dec_j}
# DEC -> DEC+J
bgb_run$BioGeoBEARS_model_object@params_table$desc[9] <- "free"
bgb_run$BioGeoBEARS_model_object@params_table$init[9] <- 0.01 # same value as d, e
```

Some further controls:

```{r, other_biogeobears_controls}
bgb_run$num_cores_to_use <- 1 # no default value on this one
bgb_run$print_optim <- FALSE # for the sake onf the vignette
```

Once everything is set up, it's a good idea to check that the input complies to the format expected by BioGeoBEARS with the provided function. Then, we're ready to run the optimisation:

```{r, run_biogeobears}
BioGeoBEARS::check_BioGeoBEARS_run(bgb_run)
res <- BioGeoBEARS::bears_optim_run(bgb_run)
```

We do get a warning, but [apparently](http://phylo.wikidot.com/biogeobears-warnings-to-ignore-mostly#unused_control_arguments) this can be ignored.

```{r, extract_decj_asr, eval=FALSE}
asr_likelihoods <- res$ML_marginal_prob_each_state_at_branch_top_AT_node[, -1]
node_states <- max.col(asr_likelihoods, ties.method = "last")
```

(Not sure this is the right item to call for the probabilities, this is not documented so I inferred it from the [plot function's code](https://github.com/nmatzke/BioGeoBEARS/blob/7b16e5263e91389d8e16b7bead4437d39b8be5bc/R/BioGeoBEARS_plots_v1.R#L432))

!!! Tips and states are mismatched smh !!!

## MuSSE

For this example, we re-use the tree from tutorial

```{r}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
phylo <- ape::rcoal(10)
phylo$tip.label <- c("bird_a", "bird_b", "bird_c", "bird_d", "bird_e", "bird_f",
                     "bird_g", "bird_h", "bird_i", "bird_j")
phylo <- phylobase::phylo4(phylo)
endemicity_status <- sample(
  x = c("not_present", "endemic", "nonendemic"), 
  size = length(phylobase::tipLabels(phylo)), 
  replace = TRUE,
  prob = c(0.6, 0.2, 0.2)
)
phylod <- phylobase::phylo4d(phylo, as.data.frame(endemicity_status))
plot_phylod(phylod = phylod)
```

SSE-class models explicitly model the inter-dependency between the evolution of a set of traits and evolutionary rates (speciation and extinction). When traits are set to represent geographic areas, such models can be used to model range evolution. For a mainland-island system, we could model the endemicity status as a ternary trait: endemic, non-endemic, or not present on the island.

Discrete-trait models with more than two states are modelled with MuSSE, which is implemented in package `diversitree`.

ASR with `diversitree` is done in three steps.
The model structure is first specified to create a likelihood function; then parameters are optimised for this function; and finally the probabilities of states of the internal nodes are determined with the resulting maximum-likelihood model.

States of the character must be specified as integers, we use the following convention:
- "endemic" = 1
- "nonendemic" = 2
- "not_present" = 3

For convenience, we include functions to switch easily between endemicity and the coded states:

```{r, create_musse_lik}
states <- endemicity_to_states(phylod@data$endemicity_status)
names(states) <- phylod@label # requires tip labels as names
tree <- as(phylod, "phylo")

# Create likelihood function
lik_musse <- diversitree::make.musse(tree = tree, states = states, k = 3)
lik_musse
```

```{r, fit_musse, eval=FALSE}
# Arbitrary initial parameter values
pars <- c(
  # lambda1 lambda2 lambda3
  0.1, 0.2, 0.2,
  # mu1 mu2 mu3
  0.03, 0.03, 0.03,
  # q12 q13 q21 q23 q31 q32
  0.01, 0, 0.02, 0.02, 0, 0.01
  )

fit_musse <- diversitree::find.mle(func = lik, x.init = pars, method = "subplex")

# MuSSE ancestral state reconstructions under the ML model
asr_musse <- diversitree::asr.marginal(lik = lik, pars = coef(fit_musse))
```

```{r, add_musse_asr_to_phylod, eval=FALSE}
asr <- t(asr)
colnames(asr) <- c("not_present", "nonendemic", "endemic")
node_states <- max.col(asr, ties.method = "last")

node_endemicity <- states_to_endemicity(node_states)

node_data <- data.frame(
  island_status = node_endemicity,
  endemic_prob = asr[, "endemic"],
  nonendemic_prob = asr[, "nonendemic"],
  not_present_prob = asr[, "not_present"],
  row.names = phylobase::nodeId(phylod, "internal")
)

phylod <- phylobase::addData(phylod, node.data = node_data)
```


SSE models in `diversitree` can be tuned further with constraints that simplify the model. We can use this to make the model closer to the assumptions of DAISIE. For example, it is not possible for a species to jump directly to the island and disappear from the mainland simultaneously; colonisation of the mainland from the island are assumed unlikely, and speciation on the island results in endemic lineages.

```{r, constrain_musse_lik, eval=FALSE}
lik_musse_c <- constrain(lik_musse) #...
pars <- c(
  # lambda1 lambda2 lambda3
  0.1, 0.2, 0.2,
  # mu1 mu2 mu3
  0.03, 0.03, 0.03,
  # q12 q13 q21 q23 q31 q32
  0.01, 0, 0.02, 0.02, 0, 0.01
  )
fit_musse <- diversitree::find.mle(func = lik, x.init = pars, method = "subplex")
```

In fact, for modelling dispersal and evolution between mainland and island, it is probably more appropriate to use an SSE model dedicated to geographic traits.

## GeoSSE

```{r, create_geosse_lik, eval=FALSE}
states <- endemicity_to_states(phylod@data$endemicity_status)
names(states) <- phylod@label # requires tip labels as names
tree <- as(phylod, "phylo")

# Create likelihood function
lik_geosse <- diversitree::make.geosse(tree = tree, states = states)
lik_geosse
```


## corHMM

```r
# set.seed(1985)
# require(ape)
# require(expm)
# require(corHMM)
# data(primates)
# phy <- primates[[1]]
# phy <- multi2di(phy)
# data <- primates[[2]]
# plot(phy, show.tip.label = FALSE)
# data.sort <- data.frame(data[, 2], data[, 3], row.names = data[, 1])
# data.sort <- data.sort[phy$tip.label, ]
# tiplabels(pch = 16, col = data.sort[, 1] + 1, cex = 0.5)
# tiplabels(pch = 16, col = data.sort[, 2] + 3, cex = 0.5, offset = 0.5)
# MK_3state <- corHMM(phy = phy, data = data, rate.cat = 1)
# phy = MK_3state$phy
# data = MK_3state$data
# model = MK_3state$solution
# model[is.na(model)] <- 0
# diag(model) <- -rowSums(model)
# # run get simmap (can be plotted using phytools)
# simmap <- makeSimmap(tree = phy, data = data, model = model, rate.cat = 1, nSim = 1,
#                      nCores = 1)
# # we import phytools plotSimmap for plotting
# phytools::plotSimmap(simmap[[1]], fsize = 0.5)

##
```

## Concluding remarks

Appropriate model choice depends on the clade and island system considered?
GeoHiSSE?

## Appendix

```{r, create island presence tip states, eval=FALSE}
tip_states <- c()
endemicity_status <- phylobase::tipData(phylod)$endemicity_status
for (i in seq_along(endemicity_status)) {
  if (grepl(pattern = "^not_present$", x = endemicity_status[i])) {
    tip_states[i] <- 1
  } else if (grepl(pattern = "^nonendemic$", x = endemicity_status[i])) {
    tip_states[i] <- 2
  } else if (grepl(pattern = "^endemic$", x = endemicity_status[i])) {
    tip_states[i] <- 3
  }
}
```

The maximum parsimony ancestral state reconstruction is from the R package
`castor`. The `castor` package only works with S3 `phylo` objects, so we need
to convert the phylogeny back to this type and then run the analysis.

```{r calculate ancestral states, eval=FALSE}
phylo <- as(phylo, "phylo")
asr <- castor::asr_max_parsimony(
  tree = phylo,
  tip_states = tip_states,
  transition_costs = "sequential"
)
``` 

This provides us with a matrix with the probabilities of the states (island 
presence/absence) at each node in the phylogeny. The first column of the matrix is not present on the island and the second colum of the matrix is present on 
the island.

```{r view ancestral state reconstruction likelihoods, eval=FALSE}
if (ncol(asr$ancestral_likelihoods) == 2) {
  colnames(asr$ancestral_likelihoods) <- c("not_present", "nonendemic")
} else if (ncol(asr$ancestral_likelihoods) == 3) {
  colnames(asr$ancestral_likelihoods) <-
    c("not_present", "nonendemic", "endemic")
}
asr$ancestral_likelihoods
```
Once we have the matrix with the likelihood of the states we can chose the most
probable state at each node using the `max.col()` function. Here we need to
make a decision that will have downstream consequences for the DAISIE data 
extracted from the tree, which is when a node has island presence and absence equally probable we need to decide whether that species should be considered on
the island. To consider it on the island use `ties.method = "last"` in the 
`max.col()` function, if you consider it not on the island use 
`ties.method = "first"`. For this example we will assume that species are on the island, but for completeness it may be worth running both and then seeing if 
there are significant downstream consequences.

```{r collapse node probabilities into a single state, eval=FALSE}
node_states <- max.col(asr$ancestral_likelihoods, ties.method = "last")
```

These values can now be converted back to string to make them more readable.

```{r, eval=FALSE}
node_states <- gsub(
  pattern = "1", replacement = "not_present", x = node_states
)
node_states <- gsub(
  pattern = "2", replacement = "nonendemic", x = node_states
)
node_states <- gsub(
  pattern = "3", replacement = "endemic", x = node_states
)
```

Now the ancestral states at the nodes is available we can combine it into our
`phylod` object.

```{r combine node data into phylod, eval=FALSE}
node_data <- data.frame(
  island_status = node_states,
  endemic_prob = asr$ancestral_likelihoods[, "endemic"],
  nonendemic_prob = asr$ancestral_likelihoods[, "nonendemic"],
  not_present_prob = asr$ancestral_likelihoods[, "not_present"],
  row.names = phylobase::nodeId(phylod, "internal")
)
phylod <- phylobase::phylo4d(
  phylo,
  tip.data = as.data.frame(endemicity_status),
  node.data = node_data
)
```



