---
title: "Tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(DAISIEprep)
library(ape)
library(phylobase)
library(ggtree)
library(ggimage)
library(castor)
```

First we simulate a phylogeny using the package `ape`

```{r simulate phylogeny}
set.seed(1)
phylo <- ape::rcoal(10)
```

`DAISIEprep` requires the species names (tip labels) in the phylogeny to be 
formatted as genus name and species name separated by an underscore. They can
also optionally have tags appended after the species name. This is common if
there are multiple tips in the phylogeny for a single species because multiple
populations have been sampled and sequenced.

```{r}
phylo$tip.label <- c("bird_a", "bird_b", "bird_c", "bird_d", "bird_e", "bird_f",
                     "bird_g", "bird_h", "bird_i", "bird_j")
```

```{r plot phylogeny}
ape::plot.phylo(phylo)
```

Then we convert to the phylogeny to a `phylo4` class defined in the package
`phylobase`. This allows use to easily work species data for each tip in the 
phylogeny, for example island endemicity status.

```{r convert phylo to phylo4}
phylo <- as(phylo, "phylo4")
phylobase::plot(phylo)
```

Now we have a phylogeny in the `phylo4` format we can easily append data. First
we randomly simulate island endemicity patterns, assuming each species has an
equal probability of being not on the island (`"not_present"`), endemic to the
island (`"endemic"`) or non-endemic to the island (`"nonendemic"`).

```{r create island endemcity data}
endemicity_status <- sample(c("not_present", "endemic", "nonendemic"), 
                            size = length(phylobase::tipLabels(phylo)), 
                            replace = TRUE)
```

Next we can add the endemicity data to our phylogenetic data using the `phylo4d`
class, again from the `phylobase` package. This call is designed for
phylogenetic and trait data to be stored together. The endemicity status needs
to be converted to a data frame in order for the column to be labelled 
correctly.

```{r convert to phylo4d}
phylod <- phylobase::phylo4d(phylo, as.data.frame(endemicity_status))
```

We can now visualise our phylogeny with the island endemicity status plotted at
the tips. This uses the `ggtree` and `ggplot2` packages.

```{r plot phylogeny with tip data}
ggtree::ggtree(phylod) +
  ggtree::geom_tippoint(
    ggplot2::aes(colour = endemicity_status), 
    size = 3
  ) +
  ggtree::theme_tree2() + 
  ggtree::geom_tiplab(as_ylab = TRUE)
```

Now that we can see the tips that are present on the island we can start to 
extract them to form our island community data set that can be used in the
`DAISIE` R package to fit likelihood models of island colonisation and 
diversification.

Before we extract species we will first create an object to store all of the 
island colonists information. This uses the `island_tbl` class introduced
in this package (`DAISIEprep`). The `island_tbl` is an S4 class that holds
a data. This `island_tbl` object can then easily be converted to a
`DAISIE_datatable` using the function `as_daisie_datatable` (more information
on this to below).

```{r create island_tbl}
island_tbl <- island_tbl()
island_tbl
```

We can see that this is a class containing an empty data frame. In order to fill
this data frame with information on the island colonisation and diversification
events we can run:

```{r extract island data, eval=FALSE}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "min"
)
island_tbl
```

However, if we do not want to extract the minimum colonisation time before the 
present, and instead want to extract the most likely colonisation from ancestral
state reconstruction we need to know the probability of the ancestors of the 
island species being on the island to determine the time of colonisation. To do 
this we can fit one of many ancestral state reconstruction methods. Here we use 
maximum parsimony as it is a simple method that should prove reliable for 
reconstructing the ancestral species areas (i.e. on the island or not on the
island). First we translate our extant species endemicity status to a numeric
representation of whether that species is on the island. We add one as the 
ancestral state reconstruction method cannot handle zero as a state. 

```{r, create island presence tip states}
tip_states <- as.numeric(grepl(pattern = "endemic", x = endemicity_status)) + 1
```

The maximum parsimony ancestral state reconstruction is from the R package
`castor`. The `castor` package only works with S3 `phylo` objects, so we need
to convert the phylogeny back to this type and then run the analysis.

```{r calculate ancestral states}
phylo <- as(phylo, "phylo")
asr <- castor::asr_max_parsimony(phylo, tip_states)
``` 

This provides us with a matrix with the probabilities of the states (island 
presence/absence) at each node in the phylogeny. The first column of the matrix is not present on the island and the second colum of the matrix is present on 
the island.

```{r view ancestral state reconstruction likelihoods}
colnames(asr$ancestral_likelihoods) <- c("not_present", "island")
asr$ancestral_likelihoods
```
Once we have the matrix with the likelihood of the states we can chose the most
probable state at each node using the `max.col()` function. Here we need to
make a decision that will have downstream consequences for the DAISIE data 
extracted from the tree, which is when a node has island presence and absence equally probable we need to decide whether that species should be considered on
the island. To consider it on the island use `ties.method = "last"` in the 
`max.col()` function, if you consider it not on the island use 
`ties.method = "first"`. For this example we will assume that species are on the island, but for completeness it may be worth running both and then seeing if 
there are significant downstream consequences.

```{r collapse node probabilities into a single state}
node_states <- max.col(asr$ancestral_likelihoods, ties.method = "last")
```
#TODO: give examples of other asr methods from castor.

These values can now be converted back to string to make them more readable.

```{r}
node_states <- gsub(pattern = "2", replacement = "island", x = node_states)
node_states <- gsub(pattern = "1", replacement = "not_present", x = node_states)
```

Now the ancestral states at the nodes is available we can combine it into our
`phylod` object.

```{r combine node data into phylod}
node_data <- data.frame(
  island_status = node_states,
  row.names = phylobase::nodeId(phylod, "internal")
)
phylod <- phylo4d(
  phylo,
  tip.data = as.data.frame(endemicity_status),
  node.data = node_data
)
```

The details above are given to make it clear the process involved in
reconstructing and assigning node states. However, to make this step easier the
above steps are in the `add_asr_node_states` function. 

```{r}
phylod <- add_asr_node_states(phylod = phylod, asr_method = "parsimony")
```

Lastly, we can plot the phylogeny, this time with the node labels for the 
ancestral island presence.

```{r plot phylogeny with tip and node data}
ggtree::ggtree(phylod) +
  ggtree::geom_tippoint(
    ggplot2::aes(colour = endemicity_status),
    size = 3,
  ) +
  ggtree::geom_nodepoint(
    ggplot2::aes(colour = island_status),
    size = 3
  ) +
  ggtree::theme_tree2() +
  ggtree::geom_tiplab(as_ylab = TRUE)
```

Quick sidenote: if you are wondering what the probabilities are at each node
and whether this should influence your decision to pick a preference for island
or mainland when the likelihood for each state are equal we can plot the
probabilities at the nodes to visualise the ancestral state reconstruction.

```{r plot ancestral state likelihoods}
node_ids <- phylobase::nodeId(phylod)[which(
  !is.na(phylobase::tdata(phylod)$island_status)
)]

node_pies <- data.frame(
  asr$ancestral_likelihoods[, "not_present"],
  asr$ancestral_likelihoods[, "island"],
  node = node_ids)

pies <- ggtree::nodepie(node_pies, cols = 1:2)

ggtree::ggtree(phylod) +
  ggtree::geom_tippoint(
    ggplot2::aes(colour = endemicity_status),
    size = 3
  ) + 
  ggtree::geom_inset(
    insets = pies, 
    width = 0.1, 
    height = 0.1
  )
```

Now we can extract the colonisation and diversification from the phylogeny
using the ancestral reconstructed island presence/absence. 

#TODO: remove eval = FALSE below when working

```{r, eval = FALSE}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "min"
)
```

In the previous example we used a single phylogeny and extracted the
colonisation and branching events from it. However, it could be the case that 
island species are from different phylogenies. Here we look at the case of the 
birds of the GalÃ pagos archipelago (excluding birds of prey). There are 8 
phylogenies to extract the colonisation and diversification date from. 

First the phylogenies need to be loaded using the function `read.nexus` from the
R package `ape`.


```{r}
coccyzus_tree <- ape::read.nexus(
  file = system.file("extdata", "Coccyzus.tre", package = "DAISIEprep")
)
columbiformes_tree <- ape::read.nexus(
  file = system.file("extdata", "Columbiformes.tre", package = "DAISIEprep")
)
finches_tree <- ape::read.nexus(
  file = system.file("extdata", "Finches.tre", package = "DAISIEprep")
)
mimus_tree <- ape::read.nexus(
  file = system.file("extdata", "Mimus.tre", package = "DAISIEprep")
)
myiarchus_tree <- ape::read.nexus(
  file = system.file("extdata", "Myiarchus.tre", package = "DAISIEprep")
)
progne_tree <- ape::read.nexus(
  file = system.file("extdata", "Progne.tre", package = "DAISIEprep")
)
pyrocephalus_tree <- ape::read.nexus(
  file = system.file("extdata", "Pyrocephalus.tre", package = "DAISIEprep")
)
setophaga_tree <- ape::read.nexus(
  file = system.file("extdata", "Setophaga.tre", package = "DAISIEprep")
)
```

Currently the phylogenies are loaded as S3 phylo objects, however, we want to
convert them into S4 phylobase objects.

```{r convert Galapagos phylos to phylo4}
coccyzus_tree <- as(coccyzus_tree, "phylo4")
columbiformes_tree <- as(columbiformes_tree, "phylo4")
finches_tree <- as(finches_tree, "phylo4")
mimus_tree <- as(mimus_tree, "phylo4")
myiarchus_tree <- as(myiarchus_tree, "phylo4")
progne_tree <- as(progne_tree, "phylo4")
pyrocephalus_tree <- as(pyrocephalus_tree, "phylo4")
setophaga_tree <- as(setophaga_tree, "phylo4")
```

Now that all of the phylogenies are loaded we can inspect them.

```{r}
phylobase::plot(coccyzus_tree, cex = 0.1)
```

We can now use a table (data frame) of the species that are on the island and
their island endemicity status.

The species names on the tree (tips labels) can be extracted by using 
`phylobase::tiplabels(coccyzus_tree)`. Make sure the spelling matches exactly
including any whitespace and underscores, and the case of the names.

```{r}
island_species <- data.frame(
  tip_labels = c("Coccyzus_melacoryphus_GALAPAGOS_L569A",
                 "Coccyzus_melacoryphus_GALAPAGOS_L571A"),
  tip_endemicity_status = c("nonendemic", "nonendemic")
)

endemicity_status <- create_endemicity_status(
  phylo = coccyzus_tree,
  island_species = island_species
)

phylod <- phylobase::phylo4d(coccyzus_tree, endemicity_status)
```

We can plot the endemicity status of these species.

```{r plot coccyzus phylogeny with tip data}
ggtree::ggtree(phylod) +
  ggtree::geom_tippoint(
    ggplot2::aes(colour = endemicity_status), 
    size = 3
  )
```

TODO change colours: not_present in black, nonendemic in blue, endemic in red.

```{r}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "min"
)
```

Instead of assigning the endemicity to each of the Galapagos bird phylogenies 
and converting them to `phylo4d` objects, this has already been done and the 
data objects have been prepared in advance and are ready to be used.

```{r load galapagos phylod data, eval=FALSE}
coccyzus_tree <- ape::read.nexus(
  file = system.file("extdata", "coccyzus_phylod.rds", package = "DAISIEprep")
)
columbiformes_tree <- ape::read.nexus(
  file = system.file(
    "extdata", "columbiformes_phylod.rds", package = "DAISIEprep"
  )
)
finches_tree <- ape::read.nexus(
  file = system.file("extdata", "finches_phylod.rds", package = "DAISIEprep")
)
mimus_tree <- ape::read.nexus(
  file = system.file("extdata", "mimus_phylod.rds", package = "DAISIEprep")
)
myiarchus_tree <- ape::read.nexus(
  file = system.file("extdata", "myiarchus_phylod.rds", package = "DAISIEprep")
)
progne_tree <- ape::read.nexus(
  file = system.file("extdata", "progne_phylod.rds", package = "DAISIEprep")
)
pyrocephalus_tree <- ape::read.nexus(
  file = system.file(
    "extdata", "pyrocephalus_phylod.rds", package = "DAISIEprep"
  )
)
setophaga_tree <- ape::read.nexus(
  file = system.file("extdata", "setophaga_phylod.rds", package = "DAISIEprep")
)
```

To see an example of the DAISIE_datatable object see

```{r Galapagos data table}
data("Galapagos_datatable", package = "DAISIE")
knitr::kable(Galapagos_datatable)
```

Each row in the table represents an independent colonisation event. The table has four columns:

* `Clade_name`: name of the independent colonisation event.
* `Status`: One of the following categories:
  + `Endemic`: applicable for both anagenetic species and radiations.
  + `Non_endemic`: if the taxon is not endemic to the island, and the age of the colonisation is based on a phylogeny where both island and non-island populations of the species have been sampled.
  + `Non_endemic_MaxAge`: if the taxon is not endemic to the island, and only an upper bound to the time of colonisation of the island is known. This applies if individuals from the island population of the species have not been sampled, but an age of the species is known. 
  + `Endemic&Non_Endemic` when an endemic clade is present and the mainland ancestor has re-colonised. For remote islands this is expected to be very rare. 
* `Missing_species`: number of island species that were not sampled for a particular clade (only applicable for radiations).
* `Branching_times`: this should be the stem age of the population/species in the case of `Non_endemic`, `Non-endemic_MaxAge` and `Endemic` anagenetic species. For cladogenetic species these should be branching times of the radiation including the stem age of the radiation. Note - if there are species within the radiation that are not found on the island (e.g. back-colonisation) the branching times of these species should be excluded, as the mainland species pool is treated as static.
