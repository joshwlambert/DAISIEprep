---
title: "Tutorial"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.align = "center", 
  fig.height = 5, 
  fig.width = 7
)
```

```{r setup}
library(DAISIEprep)
library(ape)
library(phylobase)
library(ggtree)
library(ggimage)
library(castor)
```

## Single Phylogeny Example

#### In this section we demonstrate a simple example of extracting and formatting data from a single phylogeny

First we simulate a phylogeny using the package `ape`

```{r simulate phylogeny}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
phylo <- ape::rcoal(10)
```

`DAISIEprep` requires the species names (tip labels) in the phylogeny to be 
formatted as genus name and species name separated by an underscore. They can
also optionally have tags appended after the species name. This is common if
there are multiple tips in the phylogeny for a single species because multiple
populations have been sampled and sequenced.

```{r}
phylo$tip.label <- c("bird_a", "bird_b", "bird_c", "bird_d", "bird_e", "bird_f",
                     "bird_g", "bird_h", "bird_i", "bird_j")
```

Then we convert to the phylogeny to a `phylo4` class defined in the package
`phylobase`. This allows users to easily work with species data for each tip in
the phylogeny, for example island endemicity status.

```{r convert phylo to phylo4}
phylo <- phylobase::phylo4(phylo)
phylobase::plot(phylo)
```

Now we have a phylogeny in the `phylo4` format we can easily append data. First
we randomly simulate island endemicity patterns, assuming each species has an
equal probability of being not on the island (`"not_present"`), endemic to the
island (`"endemic"`) or non-endemic to the island (`"nonendemic"`).

```{r create island endemcity data}
endemicity_status <- sample(
  x = c("not_present", "endemic", "nonendemic"), 
  size = length(phylobase::tipLabels(phylo)), 
  replace = TRUE,
  prob = c(0.6, 0.2, 0.2)
)
```

Next we can add the endemicity data to our phylogenetic data using the `phylo4d`
class, again from the `phylobase` package. This call is designed for
phylogenetic and trait data to be stored together. The endemicity status needs
to be converted to a data frame in order for the column to be labelled 
correctly.

```{r convert to phylo4d}
phylod <- phylobase::phylo4d(phylo, as.data.frame(endemicity_status))
```

We can now visualise our phylogeny with the island endemicity status plotted at
the tips. This uses the `ggtree` and `ggplot2` packages.
## change width of figure
```{r plot phylogeny with tip data}
plot_phylod(phylod = phylod)
```

Now that we can see the tips that are present on the island we can start to 
extract them to form our island community data set that can be used in the
`DAISIE` R package to fit likelihood models of island colonisation and 
diversification.

Before we extract species we will first create an object to store all of the 
island colonists information. This uses the `island_tbl` class introduced
in this package (`DAISIEprep`). The `island_tbl` is an S4 class that holds
a data. This `island_tbl` object can then easily be converted to a
`DAISIE_datatable` using the function `as_daisie_datatable` (more information
on this to below).

```{r create island_tbl}
island_tbl <- island_tbl()
island_tbl
```

We can see that this is a class containing an empty data frame. In order to fill
this data frame with information on the island colonisation and diversification
events we can run:

```{r extract island data}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "min"
)
island_tbl
```

However, if we do not want to use the "min" algorithm, and instead want to 
extract the most likely colonisation from ancestral
state reconstruction we need to know the probability of the ancestors of the 
island species being on the island to determine the time of colonisation. To do 
this we can fit one of many ancestral state reconstruction methods. Here we use 
maximum parsimony as it is a simple method that should prove reliable for 
reconstructing the ancestral species areas (i.e. on the island or not on the
island). First we translate our extant species endemicity status to a numeric
representation of whether that species is on the island. We add one as the 
ancestral state reconstruction method cannot handle zero as a state. 

```{r}
phylod <- add_asr_node_states(phylod = phylod, asr_method = "parsimony")
```

Lastly, we can plot the phylogeny, this time with the node labels for the 
ancestral island presence.

```{r plot phylogeny with tip and node data}
plot_phylod(phylod = phylod)
```

Quick sidenote: if you are wondering what the probabilities are at each node
and whether this should influence your decision to pick a preference for island
or mainland when the likelihood for each state are equal we can plot the
probabilities at the nodes to visualise the ancestral state reconstruction.

```{r plot ancestral state likelihoods}
plot_phylod(phylod = phylod, node_pies = TRUE)
```
# fix size of pie charts

Now we can extract the colonisation and diversification from the phylogeny
using the ancestral reconstructed island presence/absence. 

```{r}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "asr"
)
```

```{r display asr island_tbl}
island_tbl
```
Now that we have the `island_tbl` we can convert this to the DAISIE data table,
and more importantly, to the DAISIE data list to be used by the DAISIE inference
model. 

To convert to the DAISIE data table we used `as_daisie_datatable()`, providing
the `island_tbl` as well as the age of the island, here we use an island age
of one million years (`island_age = 1`), and whether the colonisation times 
extracted from the phylogenetic data should be considered precise 
(`precise_col_time = TRUE`). We will not discuss the details of this here, but
briefly by setting this to `TRUE` the data will tell the DAISIE model that the 
colonisation time is known without error. Setting `precise_col_time = FALSE`
will change the data to tell the DAISIE model that the colonisation time is 
uncertain and should interpret this as the upper limit to the time of 
colonisation and integrate over the uncertainty between this point and either 
the present time or to the first branching point (either speciation or 
divergence into subspecies). 

```{r}
datatable <- as_daisie_datatable(
  island_tbl = island_tbl, 
  island_age = 1, 
  precise_col_time = TRUE
)
```

Each row in the table represents an independent colonisation event. The table has four columns:

* `Clade_name`: name of the independent colonisation event.
* `Status`: One of the following categories:
  + `Endemic`: applicable for both anagenetic species and radiations.
  + `Non_endemic`: if the taxon is not endemic to the island, and the age of the colonisation is based on a phylogeny where both island and non-island populations of the species have been sampled.
  + `Non_endemic_MaxAge`: if the taxon is not endemic to the island, and only an upper bound to the time of colonisation of the island is known. This applies if individuals from the island population of the species have not been sampled, but an age of the species is known. 
  + `Endemic&Non_Endemic` when an endemic clade is present and the mainland ancestor has re-colonised. For remote islands this is expected to be very rare. 
* `Missing_species`: number of island species that were not sampled for a particular clade (only applicable for radiations).
* `Branching_times`: this should be the stem age of the population/species in the case of `Non_endemic`, `Non-endemic_MaxAge` and `Endemic` anagenetic species. For cladogenetic species these should be branching times of the radiation including the stem age of the radiation. Note - if there are species within the radiation that are not found on the island (e.g. back-colonisation) the branching times of these species should be excluded, as the mainland species pool is treated as static.

```{r}
datatable
```

To produce the DAISIE data list, i.e. the input data of the DAISIE inference 
model, we convert from the DAISIE data table produce in the last step. The
`create_daisie_data()` function will create the required list. Again we provide
an island age of one million years, and this function requires the number of 
species in the mainland pool. This will be used to calculate the number of 
species that could have potentially colonised the island but have not. When we
refer to the mainland pool, this does not necessarily have to be a continent,
it could be a different island if the source of species immigrating to an island
is largely from another nearby island (a possible example of this could be 
Madagascar being the source of species colonising Comoros). This
information is used by the DAISIE model to calculate the colonisation rate of 
the island.

```{r} 
data_list <- create_daisie_data(
  daisie_datatable = datatable, 
  island_age = 1, 
  num_mainland_species = 100
)
```

Here we just show two elements of the DAISIE data list produced. The first
element in every DAISIE data list is the island community metadata, containing
the island age and the number of species in the mainland pool that did not 
leave descendants on the island at the present day. This is an important note, 
as it is possible some mainland species colonised the island but when extinct
leaving no trace of their island presence, and due to the data being 
reconstructed from extant species these species will be missed.

```{r}
data_list[[1]]
```

Next is the first element containing information on island colonists (every
element in the list after the metadata contains information on individual island
colonists). This contains the name of the colonist, the number of missing 
species, branching times which is a vector containing the age of the island, the
colonisation time and then any cladogenesis events. Confusingly, it may be that
the branching times vector contains no branching times, when there are only two
numbers in the vector these are the island age and the colonisation time. Then 
there is the stac, which stands for status of colonist, this is a number which
tells the DAISIE model how to identify the endemicity and colonisation uncertainty
of the island colonist and lastly, the type1or2 defines which macroevolutionary
regime an island colonist is in. By macroevolutionary regime we mean the set of
rates of colonisation, speciation and extinction for that colonist. Most 
applications will assume all island clades have the same regime and thus all
are assigned type 1. However, if there is **a priori** expectation that one
clade significantly different from the rest, e.g. the Galápagos finches amongst
the other terrestrial birds of the Galápagos archipelago this clade can be 
set to type 2.

```{r}
data_list[[2]]
```

This data list can now be used in the DAISIE maximum likelihood inference model
from the R package `DAISIE`. For more information on the DAISIE data structures
and their application in the DAISIE models see this [vignette on optimising parameters using DAISIE](https://cran.r-project.org/web/packages/DAISIE/vignettes/demo_optimize.html)



## Galápagos Empirical Example

#### In this section we demonstrate an empirical use case of the package on the avifauna of the Galápagos archipelago which uses several phylogenies for different island colonists

In the previous example we used a single phylogeny and extracted the
colonisation and branching events from it. However, it could be the case that 
island species are from different phylogenies. Here we look at the case of the 
birds of the Galàpagos archipelago (excluding birds of prey). There are 8 
phylogenies to extract the colonisation and diversification date from. 

First the phylogenies need to be loaded using the function `read.nexus()` from 
the R package `ape`. Here the data is stored in `extdata` so we use 
`system.file()` to find the file and read it into the environment. This code is
functionally doing the same this as `data()` if the data we stored in the data/
folder, so if the code seems confusing just remember it is loading the phylogeny
into memory for each group.

```{r}
coccyzus_tree <- ape::read.nexus(
  file = system.file("extdata", "Coccyzus.tre", package = "DAISIEprep")
)
columbiformes_tree <- ape::read.nexus(
  file = system.file("extdata", "Columbiformes.tre", package = "DAISIEprep")
)
finches_tree <- ape::read.nexus(
  file = system.file("extdata", "Finches.tre", package = "DAISIEprep")
)
mimus_tree <- ape::read.nexus(
  file = system.file("extdata", "Mimus.tre", package = "DAISIEprep")
)
myiarchus_tree <- ape::read.nexus(
  file = system.file("extdata", "Myiarchus.tre", package = "DAISIEprep")
)
progne_tree <- ape::read.nexus(
  file = system.file("extdata", "Progne.tre", package = "DAISIEprep")
)
pyrocephalus_tree <- ape::read.nexus(
  file = system.file("extdata", "Pyrocephalus.tre", package = "DAISIEprep")
)
setophaga_tree <- ape::read.nexus(
  file = system.file("extdata", "Setophaga.tre", package = "DAISIEprep")
)
```

Currently the phylogenies are loaded as S3 phylo objects, however, we want to
convert them into S4 phylobase objects.

```{r convert Galapagos phylos to phylo4}
coccyzus_tree <- as(coccyzus_tree, "phylo4")
columbiformes_tree <- as(columbiformes_tree, "phylo4")
finches_tree <- as(finches_tree, "phylo4")
mimus_tree <- as(mimus_tree, "phylo4")
myiarchus_tree <- as(myiarchus_tree, "phylo4")
progne_tree <- as(progne_tree, "phylo4")
pyrocephalus_tree <- as(pyrocephalus_tree, "phylo4")
setophaga_tree <- as(setophaga_tree, "phylo4")
```

Now that all of the phylogenies are loaded we can inspect them.

```{r}
phylobase::plot(coccyzus_tree, cex = 0.1)
```

We can now use a table (data frame) of the species that are on the island and
their island endemicity status.

The species names on the tree (tips labels) can be extracted by using 
`phylobase::tiplabels(coccyzus_tree)`. Make sure the spelling matches exactly
including any whitespace and underscores, and the case of the names.

```{r}
island_species <- data.frame(
  tip_labels = c("Coccyzus_melacoryphus_GALAPAGOS_L569A",
                 "Coccyzus_melacoryphus_GALAPAGOS_L571A"),
  tip_endemicity_status = c("nonendemic", "nonendemic")
)
```

In order to not have to specify the endemicity status for all species in the 
phylogeny and instead focus on the island species which are usually the focus of
the research we can easily assign the endemicity status for the rest of the
species in the tree. Using `island_species` data frame produced in the last code
chunk which specifies the island endemicity status of only the island species
we can generate the rest of the endemicity statuses for those in the phylogeny
but not present on the island using `create_endemicity_status()`.

```{r}
endemicity_status <- create_endemicity_status(
  phylo = coccyzus_tree,
  island_species = island_species
)
```

Now we have the endemicity status for all species in the phylogeny, we can 
combine our phylogenetic data and endemicity status data into a single data
structure, the `phylo4d` class from the `phylobase` R package, in exactly the 
same way as in the [single phylogeny example](#Single Phylogeny Example).

```{r}
phylod <- phylobase::phylo4d(coccyzus_tree, endemicity_status)
```

We can plot the endemicity status of these species.

```{r plot coccyzus phylogeny with tip data}
plot_phylod(phylod = phylod)
```

```{r}
island_tbl <- extract_island_species(
  phylod = phylod, 
  extraction_method = "min"
)
```

```{r}
island_tbl
```

Instead of assigning the endemicity to each of the Galapagos bird phylogenies 
and converting them to `phylo4d` objects, this has already been done and the 
data objects have been prepared in advance and are ready to be used.

```{r load galapagos phylod data}
coccyzus_phylod <- readRDS(
  file = system.file("extdata", "coccyzus_phylod.rds", package = "DAISIEprep")
)
columbiformes_phylod <- readRDS(
  file = system.file(
    "extdata", "columbiformes_phylod.rds", package = "DAISIEprep"
  )
)
finches_phylod <- readRDS(
  file = system.file("extdata", "finches_phylod.rds", package = "DAISIEprep")
)
mimus_phylod <- readRDS(
  file = system.file("extdata", "mimus_phylod.rds", package = "DAISIEprep")
)
myiarchus_phylod <- readRDS(
  file = system.file("extdata", "myiarchus_phylod.rds", package = "DAISIEprep")
)
progne_phylod <- readRDS(
  file = system.file("extdata", "progne_phylod.rds", package = "DAISIEprep")
)
pyrocephalus_phylod <- readRDS(
  file = system.file(
    "extdata", "pyrocephalus_phylod.rds", package = "DAISIEprep"
  )
)
setophaga_phylod <- readRDS(
  file = system.file("extdata", "setophaga_phylod.rds", package = "DAISIEprep")
)
```

Now that we have all our data in the correct format, we are ready to extract the
island data from these trees using `extract_island_species()` using the "asr"
algorithm. 

```{r extract first Galapagos clade}
island_tbl <- extract_island_species(
  phylod = coccyzus_phylod,
  extraction_method = "asr",
  island_tbl = NULL
)
```

We can now loop through the rest of the Galapagos colonists and add them to the 
island data.

```{r extract the other Galapagos clades}
galapagos_phylod <- list(
  coccyzus_phylod, columbiformes_phylod, finches_phylod, mimus_phylod,
  myiarchus_phylod, progne_phylod, pyrocephalus_phylod, setophaga_phylod
)

for (phylod in galapagos_phylod) {
  island_tbl <- extract_island_species(
    phylod = phylod,
    extraction_method = "asr",
    island_tbl = island_tbl
  )
}
```

```{r inspect final island table}
island_tbl
```

Now we have the `island_tbl` with all the data on the colonisation, 
diversification times, and composition of each island colonist we can convert
it to a DAISIE data table and data list to be applied to the DAISIE inference 
model.

Here we use an island age of the Galápagos archipelago of four million years,
and assume that all colonisation time extracted are precise. Whether they are
in fact precise is not covered in this tutorial, and when using this pipeline
to process different data it may be worth toggling the `precise_col_time` to 
`FALSE` to check whether assuming uncertainty in colonisation times influences
conclusions. 

```{r}
datatable <- as_daisie_datatable(
  island_tbl = island_tbl, 
  island_age = 4, 
  precise_col_time = TRUE
)
```

```{r}
datatable
```

```{r} 
data_list <- create_daisie_data(
  daisie_datatable = datatable, 
  island_age = 4, 
  num_mainland_species = 100
)
```

## Adding missing species 

It is likely the case that phylogenetic data is not available for each island 
colonist present in the island community. Even in the cases where phylogenetic 
data has been inferred it may not be open-sourced in order to use for the 
extraction. In those cases it may be possible to know the stem age or crown
age if reported in the literature with the published phylogeny. This section 
is about the tools that `DAISIEprep` provides in order to handle these cases,
and generally to handle species that are missing and need to be input into the
data manually. 

For this sections, as with the previous section the core data structure we are
going to work with is the `island_tbl`. We will use the `island_tbl` for the 
Galápagos birds produced in the last section. Firstly we are going to add a 
missing species to the Galápagos finches clade. The finches have the clade name
"C_fus" in the `island_tbl` (third row). To assign a single missing species
to this clade we use following code:

```{r}
island_tbl <- add_missing_species(
  island_tbl = island_tbl, 
  num_missing_species = 1, 
  species_name = "C_fus"
)
```

The argument `species_name` uses a representative species from that island clade
to work out which colonist in the `island_tbl` to assign the specified number
of missing species (`num_missing_species`) to. In this case we used the species
in the clade name, however, this could also have been any species from the 
clade which include: 

```{r}
island_tbl@island_tbl$species[[3]]
```

The next option for adding missing species is when a phylogeny is not available
to conduct the extraction using `extract_island_species()` but the stem age of 
the island colonist is known from the literature. For our Galápagos data, this
is not actually the case as we have a phylogeny for every colonist available,
so for illustrative purposes we use the Galápagos hawk which is not in our 
data set of terrestrial birds and fabricate the time of colonisation. 

The input needed are: 

  * `island_tbl` to add to an existing `island_tbl`
  * `clade_name` a name to represent the clade, can either be a specific species
  from the clade or a genus name, or another name that represent those species
  * `status` either "endemic" or "nonendemic"
  * `missing_species` how many species are missing phylogenetic data from this 
  colonist. In the case of a singleton lineage (i.e. not an island radiation) 
  the number of missing species is zero as by adding the colonist it counts as
  one automatically. However, in the case of an island clade of at least two 
  species the number of species missing from the clade is given. For example in 
  the Galápagos finches example above it is one species missing from the clade
  * `col_time` the time of colonisation in million years before the present
  * `col_max_age` a boolean (TRUE/FALSE) on whether the colonisation time is 
  precise or should be considered a maximum upper bound on the time of 
  colonisation with some uncertainty
  * `branching_times` the times an island clade has speciated *in situ* on the 
  island. If an island clade has no speciated (i.e. is a singleton) this is NA.
  * `min_age` is the minimum lower bound time of colonisation, to be used when
  the colonisation time is assumed to be an upper bound.
  * `species` a vector of species names contained within colonist
  * `clade_type` a number represent which set of rates the colonist is assumed
  to be under, default is 1, as number greater than one assume this clade is 
  exceptionally different in its colonisation and diversification dynamics

```{r}
island_tbl <- add_island_colonist(
  island_tbl = island_tbl, 
  clade_name = "Buteo_galapagoensis", 
  status = "endemic", 
  missing_species = 0, 
  col_time = 2.5, 
  col_max_age = FALSE, 
  branching_times = NA_real_, 
  min_age = NA_real_, 
  species = "Buteo_galapagoensis", 
  clade_type = 1
)
```

Taking the example above but assuming we did not have any phylogenetic data about
the island clade we could again insert the species as missing but this time not
give the colonisation time. When this colonist later gets processed by the DAISIE
inference model it will be assumed it colonised the island any time between the 
islands formation (in the case of the Galápagos four million years ago) and the 
present.

```{r}
add_island_colonist(
  island_tbl = island_tbl, 
  clade_name = "Buteo_galapagoensis", 
  status = "endemic", 
  missing_species = 0, 
  col_time = NA_real_, 
  col_max_age = FALSE, 
  branching_times = NA_real_, 
  min_age = NA_real_, 
  species = "Buteo_galapagoensis", 
  clade_type = 1
)
```

With the new missing species added to the `island_tbl` we can repeat the
conversion steps above using `as_daisie_datatable()` and `create_daisie_data()`
to produce data accepted by the DAISIE model.



